
                  PostgreSQL için Sýkça Sorulan Sorular (SSS)
                                       
   Son güncelleme : 15 Kasým 2004 Pazartesi - 15:03:23
   
   Current maintainer: Bruce Momjian (pgman@candle.pha.pa.us)
   
   Çevirenler : Devrim Gündüz (devrim@tdmsoft.com)
   Nicolai Tufar (ntufar@tdmsoft.com)
   Volkan YAZICI (volkany@phreaker.net)
   
   Bu belgenin en güncel hali,
   http://www.PostgreSQL.org/docs/faqs/FAQ_turkish.html ve
   http://www.gunduz.org/seminer/pg/FAQ_turkish.html adreslerinde
   görülebilir.
   
   Platforma özel sorularýnýz, http://www.PostgreSQL.org/docs/index.html
   adresinde yanýtlanýr.
     _________________________________________________________________
   
                               Genel Sorular
                                      
   1.1) PostgreSQL nedir? Nasýl okunur?
   1.2) PostgreSQL'in haklarý nedir?
   1.3) PostgreSQL, hangi Unix platformlarýnda çalýþýr?
   1.4) Hangi Unix olmayan uyarlamalarý bulunmaktadýr?
   1.5) PostgreSQL'i nereden indirebilirim?
   1.6) Desteði nereden alabilirim?
   1.7) En son sürümü nedir?
   1.8) Hangi belgelere ulaþabilirim?
   1.9) Bilinen hatalar ya da eksik özelliklere nereden ulasabilirim?
   1.10) Nasýl SQL öðrenebilirim?
   1.11) PostgreSQL 2000 yýlýna uyumlu mudur?
   1.12) Geliþtirme takýmýna nasýl katýlabilirim??
   1.13) Bir hata raporunu nasýl gönderebilirim?
   1.14) PostgreSQL, diðer VTYS(DBMS) lerle nasýl karþýlaþtýrýlabilir?
   1.15) PostgreSQL'e maddi açýdan nasýl destek olabilirim?
   
                         Kullanýcý/istemci Sorularý
                                      
   2.1) PostgreSQL için ODBC sürücüleri var mý?
   2.2) PostgreSQL'i web sayfalarýnda kullanabilmek için hangi araçlar
   bulunmaktadýr?
   2.3) PostgreSQL'in grafik kullanýcý arabirimi var mýdýr?
   2.4) PostgreSQL ile iletiþimi kurabilmek için hangi dilleri
   kullanabilirim?
   
                             Yönetimsel Sorular
                                      
   3.1) PostgreSQL'i /usr/local/pgsql dizininden baþka dizinlere nasýl
   kurabilirim?
   3.2) Postmaster'ý baþlattýðýmda Bad System Call ya da core dumped
   mesajý alýyorum. Neden?
   3.3) Postmaster'ý baþlattýðýmda, IpcMemoryCreate hatasý alýyorum.
   Neden?
   3.4) Postmaster'ý, baþlattýðýmda, IpcSemaphoreCreate hatasý alýyorum.
   Neden?
   3.5) Diðer bilgisayarlarýn benim PostgreSQL veritabaný sunucuma
   baðlantýlarýný nasýl kontrol edebilirim?
   3.6) Veritabaný motorunu daha iyi baþarým icin nasýl ayarlayabilirim?
   3.7) Hangi hata ayýklama özellikleri bulunmaktadýr?
   3.8) Baðlanmaya çalýþýrken, neden "Sorry, too many clients" hatasýný
   alýyorum. Neden?
   3.9) pgsql_tmpdizinin içindeki dosyalar nelerdir?
   3.10) PostgreSQL sürümlerini yükseltmek için neden bir dump/reload
   iþlemi gerçekleþtirmek zorundayým?
   3.11) Nasýl bir donaným kullanmalýyým?br>
   
                             Ýþletimsel Sorular
                                      
   4.1) Binary cursor ve normal cursor arasýndaki fark nedýr?
   4.2) Sorgunun sadece ilk birkaç satýrýný nasýl SELECT edebilirim?
   4.3) psql'in içinde gördügüm tablolarýn ya da diðer þeylerin listesini
   nasýl alabilirim?
   4.4) Bir tablodan bir kolonu nasýl kaldýrabilirim?
   4.5) Bir satýr, tablo ve veritabaný için en fazla büyüklük nedir?
   4.6) Tipik bir metin dosyasýndaki veriyi saklamak için ne kadar disk
   alaný gereklidir?
   4.7) Veritabanýnda hangi tablo ya da index'lerin tanýmlandýðýný nasýl
   görebilirim?
   4.8) Sorgularým cok yavaþ, ya da index'lerimi kullanmýyorlar. Neden?
   4.9) Query-optimizer'ýn sorgularýmý nasýl deðerlendirdiðini, iþleme
   soktuðunu nasýl görebilirim?
   4.10) R-tree index nedir?
   4.11) Genetic Query Optimizer nedir?
   4.12) Düzenli ifade (Regular Expression) aramalarýný ve büyük/küçük
   harfe duyarsýz aramalarý nasýl yapabilirim? Bu büyük/küçük harfe
   duyarlý aramalar için index'i nasýl kullanabilirim?
   4.13) Bir sorguda, bir alanýn NULL olduðunu nasýl ortaya
   çýkarabilirim?
   4.14) Çesitli karakter tipleri arasýndaki farklar nelerdir?
   4.15.1) Nasýl serial/otomatik artan (auto-incrementing) bir alan
   yaratabilirim?
   4.15.2) Serial giriþinin deðerini nasýl alabilirim?
   4.15.3) currval() ve nextval() diðer kullanýcýlara sorun yaratmaz mý?
   4.15.4) Neden sequence sayýlarýn transaction iþleminin iptalinden
   sonra yeniden kullanýlýyor? Neden sequence/SERIAL kolonumdaki
   sayýlarda atlamalar oluyor?
   4.16) OID nedir? TID nedir?
   4.17) PostgreSQL' de kullanýlan bazý terimlerin anlamlarý nelerdir?
   4.18) Neden "ERROR: Memory exhausted in AllocSetAlloc()" hatasýný
   alýyorum?
   4.19) Hangi PostgreSQL sürümünü çalýstýrdýðýmý nasýl görebilirim?
   4.20) Neden large-object iþlemlerim, "invalid large obj descriptor"
   hatasýný veriyor?
   4.21) Þu andaki zamaný öntanýmlý deðer olarak kabul eden kolonu nasýl
   yaratýrým?
   4.22) Neden IN kullanan subquery'lerim çok yavaþ?
   4.23) Outer join iþlemini nasýl yapabilirim?
   4.24) Ayný anda birden fazla veritabanýnda nasýl iþlem yapabilirim?
   4.25) Bir fonksiyondan nasýl çoklu satýr ya da kolon döndürebilirim?
   4.26) Neden Pl/PgSQL fonksiyonlarý içinden güvenli bir þekilde tablo
   yaratma/kaldýrma iþlemlerini yapamýyoruz?
   4.27) Hangi þifreleme seçenekleri bulunmaktadýr?
   
                    PostgreSQL Özelliklerini Geniþletmek
                                      
   5.1) Kullanýcý-tanýmlý bir fonksiyon yazdým. psql'de çalýþtýrdýðým
   zaman neden core dump ediyor?
   5.2) PostgreSQL'e nasýl yeni veri tipleri/fonksiyonlar ekleyebilirim?
   5.3) Bir tuple döndürmek için bir C fonksiyonunu nasýl yazarým?
   5.4) Bir kaynak dosyasýnda deðiþiklik yaptým. Yeniden derlememe raðmen
   deðiþiklik geçerli olmuyor. Neden?
     _________________________________________________________________
   
                               Genel Sorular
                                      
    1.1) PostgreSQL nedir? Nasýl okunur?
    
   PostgreSQL, Post-Gres-Q-L. olarak okunur
   
   PostgreSQL, yeni-nesil VTYS araþtýrma prototipi olan POSTGRES
   veritabaný yönetim sisteminin geliþtirilmesidir. POSTGRES'in zengin
   veri tiplerini ve güçlü veri modelini tutarken, SQL'in geliþtirilmiþ
   alt kümesi olan PostQuel dilini kullanýr. PostgreSQL ücretsizdir ve
   kaynak kodu açýk daðýtýlýr.
   
   PostgreSQL, PostgreSQL geliþtirme listesine üye olan bir Internet
   geliþtirici takýmý tarafýndan geliþtirilir. Þu andaki koordinatör,
   Marc G. Fournier (scrappy@PostgreSQL.org). (Bu takýma nasýl
   katýlacagýnýzý öðrenmek için 1.6 numaralý maddeyi okuyunuz.) Bu takým,
   tüm PostgreSQL geliþiminden sorumludur.
   
   PostgreSQL 1.01 sürümünün yazarlarý Andrew Yu ve Jolly Chen idi.
   Bunlarýn dýþýnda bir kaç kisi de uyarlama, hata ayýklama ve kodun
   geliþtirilmesi için çalýsmýþtý. PostgreSQL'in türediði orijinal
   Postgres kodu, lisans, lisansüstü ve akademisyenler tarafýndan,
   Professor Michael Stonebraker (University of California, Berkeley)
   koordinatörlügünde yazýlmýþtýr.
   
   Berkley'deki yazýlýmýn adý Postgres idi. SQL uyumluluðu 1995'te
   eklenince, adý Postgres 95 oldu. 1996 yýlýnýn sonlarýnda adý
   PostgreSQL olarak deðiþtirildi.
   
    1.2) PostgreSQL'in haklarý nedir?
    
   PostgreSQL Data Base Management System
   
   Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group
   Portions Copyright (c) 1994-6 Regents of the University of California
   
   Permission to use, copy, modify, and distribute this software and its
   documentation for any purpose, without fee, and without a written
   agreement is hereby granted, provided that the above copyright notice
   and this paragraph and the following two paragraphs appear in all
   copies.
   
   IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
   FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
   INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND
   ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN
   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   
   THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
   INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
   PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
   CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
   UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
   
   Üstteki metin klasik açýk-kod lisansý olan BSD lisansýdýr. Kaynak
   kodun nasýl kullanýlabileceðine dair sýnýrlamalarý yoktur. Bu lisansý
   seviyoruz. Deðiþtirme niyetimiz bulunmamaktadýr.
   
    1.3) PostgreSQL, hangi Unix platforlarýnda çalýþýr?
    
   Genel olarak, modern bir Unix-uyumlu platform PostgreSQL'i
   çalýþtýracaktýr. Ayrýntýlý bilgi için kurulum belgelerine
   bakabilirsiniz.
   
    1.4) Hangi Unix olmayan uyarlamalarý bulunmaktadýr?
    
   PostgreSQL 8.0 sürümü ile , PostgreSQL artýk Win2000, WinXP ve Win2003
   gibi Microsoft Windows NT tabanlý iþletim sistemlerinde doðal olarak
   çalýþmaya baþlamýþtýr. Paketlenmiþ bir kurulum programý,
   http://pgfoundry.org/projects/pginstaller. adresinden indirilebilir.
   
   Ayrýca, http://forge.novell.com adresinde Novell Netware 6 portu
   bulunmaktadýr.
   
    1.5) PostgreSQL'i nereden indirebilirim?
    
   PostgreSQL için ana anonim ftp sitesi ftp://ftp.PostgreSQL.org/pub
   adresidir. Yansýlar için, ana web sayfamýza bakabilirsiniz.
   
    1.6) Nereden destek alabilirim?
    
   Ana e-posta listesi : pgsql-general@PostgreSQL.org. PostgreSQL
   konusundaki tartýþmalara açýktýr. Üye olmak için, aþaðýdaki satýrlarý
   e-postanýzýn body kýsmýna (konu kýsmýna deðil) yazýp,
   pgsql-general-request@PostgreSQL.org adresine gönderin:
subscribe
end

   Ayný zamanda, bir digest listesi bulunmaktadýr. Bu listeye üye olmak
   için, pgsql-general-digest-request@PostgreSQL.org adresine, body
   kýsmýnda
subscribe
end

   yazan bir e-posta atmanýz yeterli olacaktýr.
   
   Digest postalar, ana liste 30k civarýnda e-postaya ulaþtýðýnda üyelere
   gönderilmektedir.
   
   Bug'lar için bir e-posta listesi bulunmaktadýr. Bu listeye üye olmak
   için, pgsql-bugs-request@PostgreSQL.org adresine, body kýsmýnda
subscribe
end

   yazan bir e-posta atmanýz yeterli olacaktýr.
   
   Ayný zamanda, geliþtiriciler için tartýþma listesi bulunmaktadýr. Bu
   listeye üye olmak için, pgsql-hackers-request@PostgreSQL.org adresine,
   body kýsmýnda
subscribe
end

   yazan bir e-posta atmanýz yeterli olacaktýr.
   
   Bunun dýþýndaki e-posta listelerine ve PostgreSQL hakkýnda bilgiye,
   PostgreSQL WWW ana sayfasýndan ulasabilirsiniz:
   http://www.PostgreSQL.org
   
   Ayný zamanda, EFNet üzerinde, #PostgreSQL adlý bir IRC kanalý
   bulunmaktadýr. Bunun için, irc -c '#PostgreSQL' "$USER"
   irc.phoenix.net Unix komutunu kullanabilirsiniz.
   
   Ticari destek veren firmalarýn listesine
   
   http://www.postgresql.org/users-lounge/commercial-support.html
   
   adresinden ulaþbilirsiniz.
   
    1.7) En son sürüm nedir?
    
   PostgreSQL'in son sürümü 7.4.6'dýr.
   
   Her 6-8 ayda ana sürüm çýkarýlmasý planlanmaktadýr.
   
    1.8) Hangi belgelere ulaþabilirim?
    
   Daðýtýmýn içinde, kitapçýklar, kitapçýk sayfalarý ve bazý küçük
   örnekler verilmektedir. /doc dizinine bakýnýz. Ayrýca, bu el
   kitapçýklarýný online olarak http://www.PostgreSQL.org/docs/
   adresinden inceleyebilirsiniz.
   
   http://www.PostgreSQL.org/docs/awbook.html ve
   http://www.commandprompt.com/ppbook adreslerinde PostgreSQL kitaplarý
   bulunmaktadýr. PostgreSQL kitablarýnýn listesine,
   http://www.ca.PostgreSQL.org/books/ adresinden ulaþaiblirsiniz.
   Ayrýca, PostgreSQL konusundaki teknik makalelere de
   http://techdocs.PostgreSQL.org/ adresinden ulaþabilirsiniz.
   
   psql'in, \d ile baslayan veri tipler, operatorler, fonksiyonlar,
   aggregate'ler, vb. ile ilgili güzel komutlarý vardýr.
   
   Web sitemiz daha fazla belgeyi içermektedir.
   
    1.9) Bilinen hatalar ya da eksik özelliklere nereden ulaþabilirim?
    
   PostgreSQL SQL-92 uyumluluðu içindedir, standartlardan fazla da
   özellikleri bulunmaktadýr. Bilinen hatalar, eksik özellikler ve
   gelecek ile ilgili planlar için TODO listesine bakýnýz.
   
    1.10) Nasýl SQL öðrenebilirim?
    
   http:/www.PostgreSQL.org/docs/awbook.html adresindeki kitap SQL
   ögretecektir. http://www.commandprompt.com/ppbook adresinde de bir
   baska PostgreSQL kitabý bulunmaktadýr.
   
   http://www.intermedia.net/support/sql/sqltut.shtm,
   http://ourworld.compuserve.com/homepages/graeme_birchall/HTM_COOK.HTM
   http://sqlcourse.com ve http://sqlcourse2.com adreslerinde de güzel
   belgeler bulunmaktadýr.
   
   Bir baþkasý da, http://members.tripod.com/er4ebus/sql/index.htm
   adresinde bulunan "Teach Yourself SQL in 21 Days, Second Edition"
   kitabýdýr.
   
   Bazý kullanýcýlarýmýz da þu kitabý önermektedirler: "The Practical SQL
   Handbook, Bowman, Judith S., et al.,Addison-Wesley". Bazýlarý ise "The
   Complete Reference SQL, Groff et al., McGraw-Hill" kitabýný
   önermektedirler.
   
    1.11) PostgreSQL 2000 yýlýna uyumlu mudur?
    
   Evet.
   
    1.12) Geliþtirme takýmýna nasýl katýlabilirim?
    
   Öncelikle, en son kaynak kodunu indirin ve web sitemizdeki ya da
   daðýtýmýn içindeki PostgreSQL Developer belgesini okuyun. Ardýndan,
   pgsql-hackers ve pgsql-patches listelerine üye olun. Üçüncü olarak da,
   pgsql-pacthes listesine yüksek kalitede yamalar gönderin.
   
   PostgreSQL CVS arþivine eriþim izni olan, 10 kadar geliþtirici
   bulunmaktadýr. Hepsi defalarca, diðer kiþilerin yaptýðýndan çok daha
   yüksek-kaliteli yamalar göndermiþlerdir. Ayrýca biz de bu
   geliþtiricilerin ekledikleri yamalarýn yüksek kalitede olduðuna
   güveniyoruz.
   
    1.13) Bir hata raporunu nasýl gönderebilirim?
    
   PostgreSQL BugTool sayfasýna gidiniz. O sayfada bir bug bildirmek için
   neleri yapmanýz gerektiði anlatýlmýþtýr.
   
   Ayrýca, ftp://ftp.PostgreSQL.org/pub ftp adresimizde, yeni bir
   PostgreSQL sürümü ya da yamasý olup olmadýðýni kontrol ediniz.
   
    1.14) PostgreSQL, diger DBMS'lerle nasýl karþýlastýrýlabilir?
    
   Bir yazýlýmýn gücünü ölçmek için çeþitli yollar vardýr: Yazýlýmýn
   özellikleri, baþarýmý, güvenilirliði, desteði ve ücreti.
   
   Özellikler:
   
   PostgreSQL mevcut büyük ticari veritabanlarýnýn, transaction,
   subselect, trigger, view, foreign key referential integrity ve
   sophisticated locking gibi (user-defined types), rules, inheritance ve
   lock cakýþmalarýný düþürmek için multi-version uyumluluk özellikleri
   bulunmaktadýr.
   
   Performans (Baþarým):
   
   PostgreSQL, diðer ticari ve açýk kaynak kodlu veritabanlarýyla yakýn
   baþarýmý saðlar. Bazý açýlardan daha hýzlýdýr, diðer açýlardan da
   yavaþtýr. MySQL ya da daha zayýf veritabanlarý ile
   karþýlaþtýrýldýðýnda, INSERT/UPDATE iþlemlerinde, transaction bazlý
   çalýstýðýmýz için daha yavaþýz. MySQL, yukarýdaki "özellikler"
   kýsmýnda belirtilenlerden hiç birine sahip deðildir. Biz, baþarýmýmýzý
   her sürümde arttýrsak da, esneklik ve geliþmiþ özellikler için
   yapýlanmýþ durumdayýz. PostgreSQL'i MySQL ile karþýlaþtýran þu web
   sitesine bakabilirsiniz: http://openacs.org/why-not-mysql.html
   
   Güvenilirlik:
   
   DBMS'lerin güvenilir olmasý gerketiði, yoksa deðerleri olmayacaðýný
   düþünüyoruz. Çok iyi test edilmiþ, dengeli çalýsan minimum sayýda hata
   içeren kod sunmaya çalýþýyoruz. Her bir sürüm en az 1 aylýk beta
   testlerinden geçirilmektedir. Sürüm geçmiþine bakarsanýz, üretime
   hazýr, dengeli ve kararlý kodlar sunduðumuzu görebilirsiniz. Bu
   alanda, diðer veritabaný yazýlýmlarýna üstünlüðümüz olduðuna
   inanmaktayýz.
   
   Destek:
   
   E-posta listemiz, oluþan herhangi bir sorunu çözebilecek büyük sayýda
   kullanýcý ve geliþtirici grubunu içerir. Sorununuz için, en az bir
   ticari veritabaný kadar rahat çözüm bulabilirsiniz. Gelistiricilere,
   kullanýcý grubuna, belgelere ve kaynak koda direk olarak eriþebilme,
   PostgreSQL desteðini, diðer DBMS'lere göre daha önemli kýlar.
   Gereksinimi olanlara, ticari destek verilebilir. (Destek için 1.6
   bölümüne bakýnýz.)
   
   Fiyat:
   
   Ticari ve ticari olmayan tüm kullanýmlarýnýz için PostgreSQL
   ücretsizdir. Kodumuzu, yukarýda belirtilen BSD-stili lisanstaki
   sýnýrlamalar hariç, ürününüzün içine ekleyebilirsiniz.
   
    1.15) PostgreSQL'e maddi açýdan nasýl destek olabilirim?
    
   PostgreSQL, 1996 yýlýndan beri 1. sýnýf altyapýya sahiptir. Bunun
   için, yýllar boyu çalýþýp bu altyapýyý oluþturup yöneten Marc
   Fournier'e teþekkürler.
   
   Bir açýk kaynak kodlu proje için, kaliteli altyapý çok önemlidir. Bu
   altyapý, projenin kesilmesini önler ve projenin ilerlemesini
   hýzlandýrýr.
   
   Tabii ki bu altyapý ucuz deðildir. Ýþlerin yürümesi için çeþitli yýlýk
   ve anlýk harcamalarýmýz olmaktadýr. Eðer siz ya da þirketinizin bu
   çabamýza baðýþta bulunabilecek parasý varsa, lütfen
   http://store.pgsql.com/ adresine gidiniz ve baðýþta, hibede bulununuz.
   
   Web sayfasýnýn 'PostgreSQL Inc.' den bahsetmesine raðmen, "katkýda
   bulunanlar" (contributors) maddesi sadece PostgreSQL projesini
   desteklemek içindir ve belirli bir þirketin para kaynaðý deðildir.
   isterseniz, baðlantý adresine bir çek gönderebilirsiniz.
     _________________________________________________________________
   
                         Kullanýcý/Ýstemci Sorularý
                                      
    2.1) PostgreSQL icin ODBC sürücüleri var mý?
    
   iki tane ODBC sürücüsü bulunmaktadýr: PsqlODBC ve OpenLink ODBC.
   
   PsqlODBC'i
   http://gborg.postgresql.org/project/psqlodbc/projdisplay.php
   adresinden indirebilirsiniz.
   
   OpenLink ODBC http://www.openlinksw.com adresinden alýnabilir.Bu
   sürücü, kendi standart ODBC istemci yazýlýmý ile çalýstýðýndan,
   destekledikleri her platformda (Win, Mac, Unix, VMS) PostgreSQL ODBC
   bulunmalidir.
   
   Ücretsiz sürümü olmakla beraber, ticari kalitede destek almak
   isteyenlere satmak isteyeceklerdir. Sorularýnýzý lütfen
   postgres95@openlink.co.uk adresine gönderiniz.
   
    2.2) PostgreSQL'i web sayfalarýnda kullanabilmek için hangi araçlar
    bulunmaktadýr?
    
   http://www.webreview.com/ adresinde, arka planda veritabaný çalýstýran
   Web sayfalarý için giriþ seviyesinde bilgi bulunmaktadýr.
   
   Web ile bütünleþme için, PHP () mükemmel bir arabirim sunar.
   
   Karmaþýk sorunlar için, çoðu kisi Perl arabirimini ve CGI.pm ya da
   mod_perl kullanýr.
   
    2.3) PostgreSQL'in grafik kullanýcý arabirimi var mýdýr?
    
   Çeþitli grafik arabirimlerimiz bulunmaktadýr. Bunlarýn arasýnda,
   PgAccess (http://www.pgaccess.org/), PgAdmin II
   (http://www.pgadmin.org/, sadece Win32 için), RHDB Admin
   (http://sources.redhat.com/rhdb/) ve Rekall
   (http://www.thekompany.com/products/rekall/) bulunmaktadýr. Ayrýca,
   PostgreSQL için web tabanlý bir arabirim olan PHPPgAdmin
   (http://phppgadmin.sourceforge.net/) bulunmaktadýr.
   
   Daha ayrýntýlý liste için
   http://techdocs.postgresql.org/guides/GUITools adresine
   bakabilirsiniz.
   
    2.4) PostgreSQL ile iletiþimi kurabilmek için hangi dilleri kullanabilirim?
    
     * C (libpq)
     * Embedded C (ecpg)
     * Java (jdbc)
     * Python (PyGreSQL)
     * TCL (libpgtcl)
       
   Diðerleri için, http://gborg.postgresql.org adresindeki
   Drivers/Interfaces bölümüne bakabilirsiniz.
     _________________________________________________________________
   
                             Yönetimsel Sorular
                                      
    3.1) PostgreSQL'i, /usr/local/pgsql dizininden baþka dizinlere nasýl
    kurabilirim?
    
   configure betiðini çalýstýrýrken, --prefix seçeneðini veriniz.
   
    3.2) postmaster'i baslattýgýmda, a Bad System Call ya da core dumped mesajý
    alýyorum. Neden?
    
   Bunun birçok nedeni olabilir. Ancak ilk kontrol edilmesi gereken sey,
   çekirdeginize System V uzantýlarýnýn kurulu olup olmadýgýný kontrol
   etmek olabilir. PostgreSQL shared memory ve semaphores için çekirdek
   destegine gereksinim duyar.
   
    3.3) postmaster'i baþlattýðýmda, ýpcMemoryCreate hatasý alýyorum. Neden?
    
   Ya çekirdeðinizde shared memory desteðiniz düzgünce
   yapýlandýrýlmamýþtýr, ya da çekirdeðinizdeki mevcut shared memory
   miktarýný büyütmeniz gerekecektir. Gereksinim duyacaðýnýz miktar,
   mimarinize ve postmaster için ayarladýgýnýz tampon ile backend iþlemi
   sayýsýna baðlýdýr. Tüm sistemler için, tamponlar ve iþlemlerde
   öntanýmlý sayýlarla, ~ 1MB kadar yere gereksinmeniz olacaktýr.
   PostgreSQL 7.3.2 Sistem Yöneticileri Rehberi'ne, shared memory ve
   semaphorelar hakkýndaki ayrýntýlý bilgi için bakabilirsiniz.
   
    3.4) postmaster'ý baþlattýðýmda, ýpcSemaphoreCreate hatasý alýyorum. Neden?
    
   Eðer hata, "ýpcSemaphoreCreate: semget failed (No space left on
   device)" ise, çekirdeðiniz yeterli semaphore ile yapýlandýrýlmamýþ
   demektir. Postgres, her bir potansiyel backend için bir semaphore
   gereksinimi duyar. Geçici bir çözüm, postmasterý backend iþlemleri
   için daha az miktarda sýnýrla baþlatmak olabilir. -N'i varsayýlan
   deðer olan 32'den küçük bir deðerle baþlatýnýz. Daha kalýcý bir çözüm,
   çekirdeðinizin SEMMNS ve SEMMNI parametrelerini yükseltmek olacaktýr.
   
   Çalýþmayan semaphore'lar aðýr veritabaný iþlemlerinde çökme
   yaratabilirler.
   
   Eðer hata mesajýnýz baþka bir þey ise, çekirdeðinizde semaphore
   desteðini yapýlandýrmamýþ olabilirsiniz. Shared memory ve
   semaphore'lar hakkýndaki daha ayrýntýlý bilgi için PostgreSQL 7.3.2
   Sistem Yöneticileri Rehberi'ne bakabilirsiniz.
   
    3.5) Diger bilgisayarlarýn benim PostgreSQL veritabaný sunucuma
    baðlantýlarýný nasýl kontrol edebilirim?
    
   Ön tanýmlý olarak, PostgreSQL sadece yerel makineden Unix domain
   sockets kullanarak baðlanýlmasýna izin verir. Diger makineler,
   postmaster'a -i etiketini geçirmezseniz ve $PGDATA/pg_hba.conf
   dosyasýný düzenleyerek host-based authentication'a olanak vermezseniz,
   baðlantý yapamayacaklardýr.
   
    3.6) Veritabani motorunu daha iyi baþarým için nasýl ayarlayabilirim?
    
   Index'ler sorgularý hýzlandýrabilir. EXPLAIN komutu, PostgreSQL'in
   sorgunuzu nasýl yorumladýðýný ve hangi index'leri kullandýðýný
   görmenize izin verir.
   
   Eðer cok fazla INSERT iþlemi yapýyorsanýz, bunlarý büyük bir toplu
   iþlem dosyasýkullanýp COPY komutu ile veritabanýna girmeyi deneyiniz.
   Bu, tekil INSERT'lerden daha hýzlýdýr. Ýkinci olarak, BEGIN
   WORK/COMMIT transaction bloðu içinde olmayan ifadeler kendi
   transaction'larýndaymýþ gibi düþünülür. Çoklu ifadeleri tek bir
   transaction bloðu içinde yapabilirsiniz. Bu, transaction overhead'ini
   düþürecektir. Tek bir transaction bloðu içinde birden çok ifadeyi
   çalýþtýrmayý deneyebilirsiniz. Bu da ayný þekilde, transaction
   overhead'ini düþürür.
   
   Çeþitli ayarlama seçenekleri mevcuttur. fsync() iþlemini, postmaster'ý
   -o -F seçeneði ile baþlatarak devre dýþý býrakabilirsiniz. Bu iþlem,
   fsync()'lerin her transactiondan sonra diski flush etmesini
   engelleyecektir.
   
   Ayný zamanda, postmaster'i -B seçeneði ile baþlatýp, backend iþlemleri
   tarafýndan kullanýlan shared memory buffers sayýlarýný
   arttýrabilirsiniz. Eðer bu parametreyi çok yüksek tutarsanýz,
   çekirdeðinizin shared memory bölgesindeki limiti aþma olasýlýðýnýz
   yüzünden postmaster baþlayamayabilir. Her bir tampon (buffer) 8K'dýr.
   Öntanýmlý sayý ise 64 tampondur.
   
   Ayný þekilde, backend'in -S seçeneðini geçici sýralamalar için backend
   süreçleri tarafýndan kullanýlacak hafýzayý arttýrmak amacýyla
   kullanabilirsiniz. -S seçeneði kilobayt cinsinden deðer alýr ve ön
   tanýmlý deðeri 512'dir (512 K)
   
   Tablolardaki veriyi bir index'e eþlemek amacýyla gruplama için CLUSTER
   komutunu kullanabilirsiniz. Ayrýntýlý bilgi için CLUSTER komutunun
   yardým sayfasýna bakabilirsiniz.
   
    3.7) Hangi hata ayýklama özellikleri bulunmaktadýr?
    
   PostgreSQL, hata ayýklama amacýyla kullanýlabilecek durum bilgisi
   rapor eden çeþitli özeliklere sahiptir.
   
   Öncelikle, configure betiðini --enable-cassert seçeneðiyle
   çalýþtýrýrsanýz, bir çok assert() backend calýþmasýný gözlemler ve
   beklenmeyen bir durumda programý durdurur.
   
   Postmaster ve postgres çeþitli hata ayýklama seçeneklerine sahiptir.
   Öncelikle, postmaster'ý baþlattýðýnýzda, standart çýktýyý ve hatalarý
   bir log dosyasýna yönlendirdiðinize emin olun:
cd /usr/local/pgsql
./bin/postmaster >server.log 2>&1 &

   Bu iþlem PostgreSQL ana dizinine server.log dosyasý yerleþtirecektir.
   Bu dosya sunucunun yaþadýðý sorunlar ya da hatalar hakkýnda yararlý
   bilgiler içerir. -d seçeneði, hata ayýklama seviyesini belirten bir
   rakam ile kullanýlýr. Yüksek hata ayýklama seviyelerinin büyük log
   dosyalarý oluþturacaðýný unutmayýnýz.
   
   Eðer postmaster çalýþmýyorsa, postgres backend'ini komut satýrýndan
   çalýþtýrabilir ve SQL ifadenizi direk olarak yazabilirsiniz. Bu sadece
   hata ayýklama amacýyla önerilir. Burada, noktalý virgülün deðil de
   yeni bir satýrýn sorguyu sonlandýrdýðýný unutmayýnýz. Eðer hata
   ayýklama sembolleri ile derlediyseniz, ne olduðunu görmek için bir
   hata ayýklayýcý kullanabilirsiniz. backend postmaster'dan
   baþlatýlmadýðýndan, eþdeðer bir ortamda çalýþmamaktadýr ve
   locking/backend etkileþim sorunlarý artabilir.
   
   Eðer postmaster çalýþýyorsa, bir pencerede psql'i çalýþtýrýn ve psql
   tarafýndan kullanýlan postgres sürecinin süreç numarasýný (PID) bulun.
   Postgres süreci ile iliþkilendirmek için bir hata ayýklarýcý kullanýn.
   Sorgularý psql aracýlýðý ile çalýþtýrabilirsiniz. Eðer postgres
   baþlangýcýnda hata ayýklamak istiyorsanýz, PGOPTIONS="-W n" seçeneðini
   ayarlayabilir ve psql'i baþlatabilirsiniz. Bu iþlem, baþlangýcýn n
   saniye kadar gecikmesini saðlayacaktýr; böylece hata ayýklayýcýyý
   sürece iliþkilendirdikten sonra baþlangýç sürecinin devam etmesini
   saðlayabilirsiniz.
   
   postgres programý hata ayýklama ve baþarým ölçümleri için -s, -A ve -t
   seçeneklerine sahiptir.
   
    3.8) Baðlanmaya çalýþýrken, neden "Sorry, too many clients" hatasýný
    alýyorum?
    
   Postmaster'ýn eþzamanlý olarak baþlatabileceði backend süreçleri
   sýnýrlarýný arttýrmanýz gerekmektedir.
   
   Ön tanýmlý deðer 32 süreçtir. Bunu, postmaster'ý uygun -N deðeri ile
   ya da postgresql.conf dosyasýný düzenleyerek yeniden baþlatmakla
   arttýrabilirsiniz.
   
   Eðer -N deðerini 32'den büyük yapacaksanýz, ayný zamanda -B deðerini
   de deðiþtirmeniz gerektiðini unutmayýn. -B, -N'nin en az 2 katý kadar
   olmalýdýr; daha iyi baþarým için bu sayýyý daha da arttýrmalýsýnýz.
   Yüksek sayýdaki backend süreçleri için, çeþitli çekirdek yapýlandýrma
   parametrelerini arttýrmanýz gerekecektir. Yapýlmasý gerekenler,
   SHMMAX, SEMMNS, SEMMNI, NPROC, MAXUPRC ve açýlabilecek dosyalarýn
   maksimum sayýsý olan NFILE ve NINODE deðerlerini karýþtýrmaktýr. Bunun
   nedeni, PostgreSQL'in izin verilen backend süreçlerinin sayýsý
   üzerinde bir sýnýrý olmasýdýr. Böylelikle sistem kaynaklarýnýn dýþýna
   çýkýlmayacaktýr.
   
   PostgreSQL'in 6.5 sürümüne kadar, en fazla backend sayýsý 64 idi ve
   bunu deðiþtirmek için include/storage/sinvaladt.h dosyasý içindeki
   MaxBAckendid sabitini deðiþtirdek sonra yazýlýmý yeniden derlemek
   gerekiyordu.
   
    3.9) pgsql_tmp dizinin içindeki dosyalar nelerdir?
    
   Sorgu çalýstýrýcý (query executer) tarafýndan yaratýlan geçici
   dosyalardýr. Örnegin, bir sýralama ORDER BY ile yapýlacaksa ve
   sýralama backend'in -s parametresinin izin verdiðinden daha fazla
   alana gereksinim duyuyorsa, ekstra veriyi tutmak için geçici dosyalar
   yaratýlýr.
   
   Geçici dosyalar, eðer sýralama sýrasýnda backend göçmezse otomatik
   olarak silinecektir. Eðer çalýþan durumda bir backend'iniz yoksa,
   pg_tempNNN.NN dosyalarýný silmeniz güvenlidir.
   
    3.10) PostgreSQL sürümlerini yükseltmek için neden bir dump/reload iþlemi
    gerçekleþtirmek zorundayým?
    
   PostgreSQL takýmý ara sürümlerde sadece küçük deðiþiklikler
   yapmaktadýr; bu yüzden 7.2 sürümünden 7.2.1'e yükseltmek dump/restore
   iþlemi gerekmemektedir. Ancak, esas sürümlerde (örnek: 7.2'den 7.3'e)
   çoðunlukla sistem tablolarýnýn ve veri dosyalarýnýn iç yapýsý
   deðiþtirilir. Bu deðiþiklikler çoðunlukla karmaþýktýr; dolayýsýyla
   veri dosyalarýnýn geriye dönük uyumluluðu iþlemlerini yapmýyoruz. Dump
   iþlemi, veriyi genel biçimde alacaðýndan yeniden yükleme esnasýnda
   veri, yeni iç biçime uygun þekilde yerleþtirilecektir.
   
   Disk biçiminin deðiþmediði sürümlerde, pg_upgrade betiði güncellemenin
   bir dump/restore gerektirmeden yapýlmasýný saðlayacaktýr. pg_upgrade
   betiðinin o sürüm için bulunup bulunmadýðýný sürüm notlarý içinde
   bulabilirsiniz.
   
    3.11) Nasýl bir donaným kullanmalýyým?
    
   PC donanýmý tamamen uyumlu olduðu için, insanlar tüm PC donanýmlarýnýn
   ayný kalitede olduðunu düþünürler. Oysa böyle deðildir. ECC RAM, SCSI
   ve kaliteli anakartlar daha ucuz donanýmlara göre daha çok
   güvenilirlerdir ve baþarýmlarý daha yüksektir. PostgreSQL hemen hemen
   tüm donanýmda çalýþabilmektedir, ancak güvenilirlik ve baþarým önemli
   ise donaným seçeneklerini çok iyi araþtýrmak gereklidir. E-posta
   listelerimi donanýmlarla ilgili sorular ve de ticaret için
   kullanýlabilir.
     _________________________________________________________________
   
                             Ýþletimsel Sorular
                                      
    4.1) Binary cursor ve normal cursor arasýndaki fark nedir?
    
   DECLARE yardým sayfasýna bakýnýz.
   
    4.2) Sorgunun sadece ilk birkaç satýrýný nasýl SELECT edebilirim?
    
   FETCH yardým sayfasýna bakýnýz, ya da SELECT ... LIMIT ... kullanýnýz.
   
   Ýlk birkaç satýrý almak isteseniz bile, tüm sorgu deðerlendirilmek
   durumunda kalýnabilir. ORDER BY içeren bir sorgu düþünün. Eðer ORDER
   BY iþe eþleþen bir index varsa, PostgreSQL istenen ilk birkaç satýrý
   iþleyebilir, ya da tüm sorgu istenen satýrlar üretilene kadar
   iþlenebilir.
   
    4.3) psql'in içinde gördügüm tablolarýn ya da diðer þeylerin listesini
    nasýl alabilirim?
    
   pgsql/src/bin/psql/describe.c içindeki psql kaynak kodunu
   okuyabilirsiniz. Bu kod, psql'in \ ile baþlayan komutlarýnýn çýktýsýný
   olusturan SQL komutlarýný içerir. Ayný zamanda, psql'i -E seçeneði ile
   baþlatýp, verdiðiniz komutlarý çalýþtýrmak için yaptýðý sorgularýn
   çýktýlarýný görebilirsiniz.
   
    4.4) Bir tablodan bir kolonu nasýl kaldýrabilirim?
    
   Bu özellik (ALTER TABLE DROP COLUMN) 7.3 sürümü ile gelmiþtir. Eski
   sürümlerde aþaðýdakileri uygulamalýsýnýz:
BEGIN;
LOCK TABLE old_table;
SELECT ...  -- select all columns but the one you want to remove
INTO TABLE new_table
FROM old_table;
DROP TABLE old_table;
ALTER TABLE new_table RENAME TO old_table;
COMMIT;
                
    4.5) Bir satýr, tablo ve veritabaný için en fazla büyüklük nedir?
    
   Sýnýrlar:
   
   Veritabaný için en fazla büyüklük nedir?
   Sýnýrsýz (32 TB'lýk veritabaný bulunmaktadýr)
   Bir tablo için en fazla büyüklük nedir?
   32 TB
   Bir satýr için en fazla büyüklük nedir?
   1.6 TB
   Bir alan için en fazla büyüklük nedir?
   1 GB
   Tabloda en fazla satýr sayýsý kaçtýr?
   Sýnýrsýz
   Bir tabloda olabilecek en fazla kolon sayýsý kaçtýr?
   Kolon tiplerine baðlý olarak 250-1600
   Bir tabloda olabilecek en fazla index sayýsý kaçtýr?
   Sýnýrsýz
   
   Tabii ki bunlar aslýnda sýnýrsýz degildir. Burada belirtilen sýnýrlar,
   fiziksel sýnýrlarýn haricindeki sýnýrlardýr. Boþ disk alaný,
   hafýza/takas alaný na baðlý sýnýrlamalar vardýr. Baþarým, sýnýr
   deðerlere yaklaþtýkça, ya da deðerler çok büyük olduðunda düþebilir.
   
   Bir tablo için büyüklük sýnýrý olan 32 TB, iþletim sisteminin büyük
   dosya desteði olup olmamasýndan baðýmsýzdýr. Büyük tablolar, 1 GB'lik
   dosyalarda saklandýðý için, dosya sistemi sýnýrlarýnin bir önemi
   yoktur.
   
   Tablo ve kolon sayýsý büyüklükleri, ön tanýmlý blok büyüklüðü 32k ya
   çýkarýlarak arttýrýlabilir.
   
    4.6) Tipik bir metin dosyasýndaki veriyi saklamak için ne kadar disk alaný
    gereklidir?
    
   Bir PostgreSQL veritabaný, veriyi "flat" metin dosyasýnda saklamak
   için gereken alanýn 5 kat fazla disk alanýna gereksinim duyabilir.
   
   Her satýrýnda bir tamsayý ve metin (text) içeren, 100.000 satýrlýk bir
   dosya düþünün. Her satýrýn ortalama 20 byte olduðunu farzedelim. Metin
   dosyasý 2.8 MB olacaktýr. Bu veriyi tutan PostgreSQL veritabaný
   yaklaþýk 6.4 MB yer kaplayacaktýr.
  36 byte: Her bir satýr baþlýðý (yaklaþýk)
+ 24 byte: Bir tamsayý (int) alaný ve bir metin (text) alaný
+  4 byte: Sayfada tuple a pointer
----------------------------------------
  64 byte -> kayýt baþýna

   PostgreSQL'de veri sayfasý (data page) büyüklüðü 8192 byte (8k)dýr,
   dolayýsýyla:
8192 byte -> page baþýna
-------------------------  =  Her bir veritabaný page'ý baþýna 128 satýr (yaklaþýk)
  Satýr baþýna 64 byte

100000 veri satýrý
--------------------  =  782 veritabaný sayfasý
     128 satýr

   782 veritabaný sayfasý * sayfa baþýna 8192 byte = 6,406,144 bytes (6.4
   MB)
   
   Index'ler çok fazla yere gereksinim duymazlar, ama index'lenmiþ veriyi
   tutacaklarýndan büyük olabilirler.
   
   NULL deðerler bitmapler içinde tutulur; dolayýsýyla çok az yer
   kaplarlar.
   
    4.7) Veritabanýnda hangi tablo ya da index'lerin tanýmlandýðýný nasýl
    görebilirim?
    
   psql, bu tür bilgileri göstermek için, \ ile baþlayan bir çok komut
   sunmaktadýr. \? komutu ile bu komutlarý görebilirsiniz. Ayrýca,
   bunlarý açýklayan ve pg_ ile baþlayan çok sayýda sistem tablosu
   bulunmaktadýr. Ayný zamanda, psql -l ile tüm veritabanlarýný
   listeyelebirsiniz.
   
   Ayrýca, pgsql/src/tutorial/syscat.source kodunu inceleyebilirsiniz. Bu
   dosya, veritabaný sistem dosyalarýndan bilgiyi almak için gereksinim
   duyulan bir çok SELECT'leri gösterir.
   
    4.8) Sorgularým cok yavaþ, ya da index'lerimi kullanmýyorlar. Neden?
    
   Indexler her sorgu tarafýndan otomatik olarak kullanýlmazlar. Indexler
   eðer bir tablonun büyüklüðü minimum bir büyüklükten fazla ise ve sorgu
   tablodaki satýrlarýn sadece küçük bir yüzdesini seçiyorsa kullanýlýr.
   Bunun nedeni, index eriþiminin neden olduðu raslansal disk eriþimi nin
   diskin ya da tablonun sýralý okunmasýndan daha yavas olabilmesidir.
   
   Bir index'in kullanýlýp kullanýlmayacaðýný belirlemek için, PostgreSQL
   tablo hakkýndaki istatistiklere gereksinmesi vardýr. Bu istatistikler,
   VACUUM ANALYZE kullanýlarak toplanýrlar. Optimizer, istatistikleri
   kullanarak, tabloda kaç satýr olduðunu ve bilir ve indexin kullanýlýp
   kullanýlmayacaðýna daha iyi karar verir. Istatistikler, ayný zamanda
   en uygun join sýrasýný ve yöntemini belirlemekte çok önemlidir.
   Ýstatistik toplanmasý, tablo içerikleri deðiþtikçe periyodik olarak
   yapýlmalýdýr.
   
   Indexler normalde ORDER BY sorgularý ya da join iþlemlerini
   gerçekleþtirmek için kullanýlmazlar. Açýk bir sýralamayý takip eden
   sýralý bir arama (sequential scan), büyük bir tabloda index aramasý
   yapmaktan genelde daha hýzlýdýr.
   Ancak, ORDER BY ile birleþmiþ LIMIT genellikle bir index
   kullanacaktýr; çünkü tablonun sadece belirli bir miktarý
   döndürülecektir. Aslýnda, MAX() ve MIN() fonksiyonlarýnýn index
   kullanmamalarýndan dolayý, bu gibi deðerleri ORDER BY ve LIMIT
   kullanarak da almak olasýdýr:
    SELECT col
    FROM tab
    ORDER BY col [ DESC ]
    LIMIT 1;

   Eðer optimizer'ýn sýralý arama yapmasýnýn yanlýþ olduðuna
   inanýyorsanýz, SET enable_seqscan TO 'off' kullanýn ve index kullanan
   aramalarýn hala daha hýzlý olup olmadýðýný görün.
   
   LIKE ya da ~ gibi operatörler kullanýyorsanýz, index'ler sadece
   aþaðýdaki koþullarda kullanýlabilir:
     * Arama dizininin baþý, dizinin baþý ile baðlanmalýdýr. Yani,
          + LIKE sorgularý % ile baþlamamalýdýr.
          + Düzenli ifade sorgularý ^ iþe baþlamamalýdýr.
     * Arama metni bir karakter sýnýfý ile baþlayamaz. Örnek: [a-e]
     * ILIKE ve ~* gibi büyük/küçük harfe duyarsýz aramalar index'lerden
       yararlanmazlar. Onun yerine, bölüm 4.12'de anlatýlan fonksiyonel
       index'leri kullanabilirsiniz.
     * initdb sýrasýnda öntanýmlý C locale'i kullanýlmalýdýr.
       
    4.9) query-optimizer'ýn sorgularýmý nasýl deðerlendirdiðini, iþleme
    soktuðunu nasýl görebilirim?
    
   EXPLAIN yardým sayfasýna bakýnýz.
   
    4.10) R-tree index nedir?
    
   R-tree index, uzaysal (spatial) verileri indexlemek için kullanýlýr.
   Bir hash index, dizi aramalarýnda (range search) kullanýlamaz. B-tree
   index dizi aramalarýnda sadece tek boyutlu çalýþmaktadýr. R-tree, çok
   boyutlu veriyi destekler. Örneðin, eðer bir R-tree index point veri
   tipi üzerinde inþa edililebilirse, sistem "select all points within a
   bounding rectangle" gibi sorgulara daha verimli yanýtlar verecektir.
   
   Orijinal R-tree tasarýmýný açýklayan belge:
   
   Guttman, A. "R-trees: A Dynamic Index Structure for Spatial
   Searching." Proceedings of the 1984 ACM SIGMOD Int'l Conf on Mgmt of
   Data, 45-57.
   
   Bu belgeyi, Stonebraker'ýn "Readings in Database Systems" kitabýnda
   bulabilirsiniz.
   
   Gömülü R-tree indexleri poligon ve boxlarý kullanabilir. Teorik
   olarak, R-tree indexlerin özelliklerini geniþletmek bir miktar çaba
   gerektirir ve bunun nasýl yapýlacaðýna dair bir belgemiz henüz
   bulunmamaktadýr.
   
    4.11) Genetic Query Optimizer nedir?
    
   GEQO modülü, Genetic Algorithm(GA) kullanýlarak tablolar
   birleþtirildiðinde sorgu optimizasyonunu hýzlandýrýr.
   
    4.12) Düzenli ifade (Regular Expression) aramalarýný ve büyük/küçük harfe
    duyarsýz aramalarý nasýl yapabilirim? Bu büyük(küçük harfe duyarlý aramalar
    için index'i nasýl kullanabilirim?
    
   ~ operatörü düzenli ifade eþleþmesi ve ~* büyük/küçük harfe duyarsýz
   düzenli ifade eþleþmesi yapar. Büyük/küçük harfe duyarlý olan LIKE'ýn
   büyük/küçük harfe duyarsýz olan biçimi ILIKE'týr ve PostgreSQL 7.1
   sürümü ile birlikte gelmiþtir.
   
   Büyük-küçük harfe duyarsýz eþitlik karþýlaþtýrmalarý aþaðýdaki gibi
   ifade edilir:
SELECT *
FROM tab
WHERE lower(col) = 'abc'
                
   Bu standart bir index yaratmayacaktýr. Ancak eðer fonksiyonel bir
   index yaratýrsanýz; o kullanýlacaktýr:
CREATE INDEX tabindex on tab (lower(col));

    4.13) Bir sorguda, bir alanin "NULL" olduðunu nasýl ortaya çýkarabilirim?
    
   Kolonu, IS NULL ve IS NOT NULL ile test edebilirsiniz.
   
    4.14) Çesitli karakter tipleri arasýndaki farklar nelerdir?
    
Veri Tipi           Ýç Adý              Not
--------------------------------------------------
VARCHAR(n)      varchar         boyut en büyük uzunluðu verir; sadece verilen kadar veri tutulur.
CHAR(n)         bpchar          belirtilen uzunluða kadar sonuna  boþluk eklenir.
TEXT            text            uzunlukta herhangi bir üst sýnýr yoktur.
BYTEA           bytea           variable-length byte array (null-byte safe)
"char"          char            bir karakter
                
   Ýç adlarý (internal name) sistem kataloglarýný ve bazý hata
   mesajlarýný incelerken göreceksiniz.
   
   Ýlk dört veri tipi "varlena" tipidir (yani, diskteki ilk 4 bayt
   uzunluktur; devamý da veridir.) Dolayýsýyla, kullanýlan gerçek alan,
   belirtilen alandan biraz daha büyüktür. Ancak, bu veri tipleri,
   sýkýþtýrýlmaya tabi tutulabilir; dolayýsýyla disk alaný beklenilenden
   küçük olabilir. VARCHAR(n) büyüklüðü artabilen ama en büyük uzunluðu
   sýnýrlý olan verileri saklamak için en uygun yöntemdir. TEXT, 1 GB
   büyüklüðe kadar olan verileri tutmak için kullanýlýr.
   
   CHAR(n), ayný uzunluktaki dizilerin saklanmasý için kullanýmýr.
   CHAR(n) belirtilen uzunluða kadar boþluk ile doldurur; ancak
   VARCHAR(n) sadece verilen karakterleri saklar. BYTEA binary veri
   saklamak içindir; ayrýca "NULL" bayt içeren deðerleri de saklar.
   Burada anlatýlan üç veri tipi de benzer baþarým karakteristiklere
   sahiptir.
   
    4.15.1) Nasýl serial/otomatik artan (auto-incrementing) bir alan
    yaratabilirim?
    
   PostgreSQL'de SERIAL veri tipi vardýr. Bu veri tipi bir sequence ve
   kolon üzerinde bir index yaratýr.
   
   Örnek, aþaðýdaki sorgu:
CREATE TABLE person (
    id   SERIAL,
    name TEXT
);
                
   buna çevrilir:
CREATE SEQUENCE person_id_seq;
CREATE TABLE person (
    id   INT4 NOT NULL DEFAULT nextval('person_id_seq'),
    name TEXT
);
CREATE UNIQUE INDEX person_id_key ON person ( id );
                
   Sequenceler hakkýnda daha fazla bilgi için create_sequence yardým
   sayfasýna bakabilirsiniz. Her satýrýn OID alanýný tekil bir sayý
   olarak alabilirsiniz. Ancak, veritabanýnýzýn dump'ýný alýp yeniden
   yüklerseniz, OID deðerlerini koruyabilmek için pg_dump'ýn -o
   parametresini ya da "COPY WITH OIDS" seçeneðini kullanmanýz
   gerekecektir.
   
    4.15.2) SERIAL giriþinin degerini nasýl alabilirim?
    
   Bir yaklaþým, sequence nesnesindeki SERIAL deðerini, veriyi girmeden
   önce nextval() ile alýp, aldýðýnýz deðeri kendinizin girmesidir.
   4.15.1'deki örnek tabloyu kullanarak bir örnek verelim:
new_id = execute("SELECT nextval('person_id_seq')");

    execute("INSERT INTO person (id, name) VALUES (new_id, 'Blaise Pascal')");

   Diðer sorgular için new_id'de yeni deðerin saklanmasý gerekir.
   Otomatik olarak yaratýlan SEQUENE nesnesinin adý, <tablo adý>_<serial
   kolonu adý>_seq þeklinde olacaktýr (< > iþaretleri olmadan).
   
   Alternatif olarak, atanmýþ SERIAL deðerini, deðer girildikten sonra
   currval() fonksiyonu ile alabilirsiniz:
                execute("INSERT INTO person (name) VALUES ('Blaise Pascal')");
                new_id = execute("SELECT currval('person_id_seq')");
                
   Son olarak, ön tanýmlý deðeri bulmak için INSERT ifadesinden dönen OID
   deðerini kullanabilirsiniz; ancak bu en az taþýnabilir çözüm
   olacaktýr. Perl'de, Edmund Mergl'in DBD:Pg mödülü ile birlikte DBI
   kullanarak, OID deðeri $sth->execute() çalýþtýrýldýktan sonra
   $sth->(pg_oid_status) ile alýnabilir.
   
    4.15.3) currval() ve nextval() diðer kullanýcýlara sorun yaratmaz mý?
    
   Hayýr. curval(), tüm kullanýcýlar deðil, backend tarafýndan atanan
   geçerli deðeri döndürür.
   
    4.15.4) Neden sequence sayýlarý transaction iþleminin iptalinden sonra
    yeniden kullanýlýyor? Neden sequence/SERIAL kolonumdaki sayýlarda atlamalar
    oluyor?
    
   Uyumluluðu arttýrmak için, sequence deðerleri çalýþan transaction'lara
   gerektiði þekilde aktarýlýr ve transaction bitene kadar o deðer
   kilitlenmez. Bu, iptal edilen transaction iþlemleri nedeniyle
   boþluklara neden olur.
   
    4.16) OID nedir? TID nedir?
    
   OIDler, tekil satýr numaralarýna PostgreSQL'in yanýtýdýr.
   PostgreSQL'de yaratýlan her sayý, tekil bir OID alýr. initdb iþlemi
   sýrasýnda yaratýlan tüm OID'ler 16384'ten küçüktür
   (backend/access/transam.h). Kullanýcýlar tarafýndan yaratýlan tüm
   OID'ler bu sayýya eþit ya da bu sayýdan büyüktür. Varsayýlan durumda,
   tüm bu OIDler sadece bir tablo ya da veritabanýnda deðil, tüm
   PostgreSQL kurulumunda tekildir.
   
   PostgreSQL OIDleri, tablolar arasýnda satýrlarý iliþkilendirmek için
   kendi iç tablolarýnda kullanýr. Bu OIDler belirli kullanýcý
   satýrlarýný belirtmek için kullanabilir ve join iþlemlerinde
   kullanýlýr. OID deðerlerini saklamak için OID kolon tipini kullanmanýz
   önerinir. Daha hýzlý bir eriþim için, OID alanýnda bir index
   yaratabilirsiniz.
   
   OID'ler yeni satýrlara, tüm veritabanlarý tarafýnda kullanýlan ortak
   bir alandan atanýrlar. Eðer OID'i baþka bir deðere eþitlemek
   isterseniz ya da tablonun bir kopyasýný orijinal OIDler ile çýkarmak
   isterseniz, bu mümkündür:
                        CREATE TABLE new_table(old_oid oid, mycol int);
                        SELECT old_oid, mycol INTO new FROM old;
                        COPY new TO '/tmp/pgtable';
                        DELETE FROM new;
                        COPY new WITH OIDS FROM '/tmp/pgtable';
                
   OIDler 4-bit tamsayý olarak saklanýrlar ve 4 milyarda overflow
   olacaktýr. Kimse bu sayýya ulaþtýðýna dair bir bilgi iletmedi ve bu
   sýnýrý kimse bu sýnýra ulaþmadan kaldýracaðýz.
   
   TIDler, belirli fiziksel satýrlar block ve offset deðerleri ile
   belirtmekte kullanýlýr. TIDler, satýrlar deðiþtiðinde ya da yeniden
   yüklendiðinde deðiþirler. Index girdileri tarafýndan fiziksel
   satýrlarý göstermek için kullanýlýrlar.
   
    4.17) PostgreSQL'de kullanýlan bazý terimlerin anlamlarý nelerdir?
    
   Kaynak kodun bir kýsmý ve eski belgeler, daha geniþ kullaným alaný
   olan terimleri kullanýrlar. Bunlarýn bazýlarý:
     * table, relation, class
     * row, record, tuple
     * column, field, attribute
     * retrieve, select
     * replace, update
     * append, insert
     * OID, serial value
     * portal, cursor
     * range variable, table name, table alias
       
   Genel veritabaný terimleri,
   http://hea-www.harvard.edu/MST/simul/software/docs/pkgs/pgsql/glossary
   /glossary.html adresinde bulunabilir.
   
    4.18) Neden "ERROR: Memory exhausted in AllocSetAlloc()" hatasýný alýyorum?
    
   Sisteminizde sanal belleðinizi tüketmiþ olabilirsiniz, ya da
   çekirdeðiniz belli kaynaklar icin düþük bir sýnýra sahip olabilir.
   postmaster'ý baþlatmadan önce aþaðýdakileri deneyebilirsiniz:
ulimit -d 262144
limit datasize 256m
                
   Kabuðunuza baðlý olarak, bunlardan sadece biri olumlu sonuç
   verecektir, ama bu iþlem veri segment sýnýrýnýzý arttýracak, ve belki
   de sorgunuzun tamamlanmasýný saðlayacaktýr. Bu komut, varolan iþleme
   (current process) ve komut çalýþtýrýldýktan sonraki tüm alt iþlemlere
   uygulanýr. Eðer SQL istemcinizle, backend'in çok fazla veri döndürmesi
   nedeniyle bir sorun yaþýyorsanýz, bunu istemciyi baþlatmadan önce
   deneyiniz.
   
    4.19) Hangi PostgreSQL sürümünü çalýþtýrdýðýmý nasýl görebilirim?
    
   psql arabiriminde, select version(); yazýnýz.
   
    4.20) Neden large-object iþlemlerim, "invalid large obj descriptor"
    hatasýný veriyor?
    
   Large object iþlemlerinizin uçlarýna, yani lo_open ... lo_close
   komutlarýnýn çevresine, BEGIN WORK ve COMMIT koymanýz gerekmektedir;
   
   Þu anda, PostgreSQL kurallarý large objectleri transaction commit
   edildiðinde kapatarak uygulamaktadýr. Dolayýsýyla handle ile yapýlacak
   ilk þey invalid large obj descriptor hatasý ile
   sonuçlanacaktýr.Dolayýsýyla çalýþan kodunuz eðer transaction
   kullanmazsanýz hata mesajlarý üretecektir.
   
   Eðer ODBC gibi bir istemci arabirimi kullanýyorsanýz, auto-commit'i
   kapatmanýz gerekebilir.
   
    4.21) Þu andaki zamaný öntanýmlý deðer olarak kabul eden How do I create a
    column that will default to the current time?
    
   Alttakini kullanabilirsiniz:
CURRENT_TIMESTAMP:
CREATE TABLE test (x int, modtime timestamp DEFAULT CURRENT_TIMESTAMP );
                
    4.22) Neden IN kullanan subquery'lerim çok yavas?
    
   7.4 sürümünden önce, subqueryler. Eðer subquery sadece birkaç satýr ve
   outer query bol sayýda satýr döndürüyorsa, IN en hýzlýsýdýr. Sorgularý
   hýzlandýrmak için IN yerine EXISTS kullanýn:
SELECT *
    FROM tab
    WHERE col1 IN (SELECT col2 FROM TAB2)
                
   sorgusunu, aþaðýdaki ile deðiþtirin:
SELECT *
    FROM tab
    WHERE EXISTS (SELECT col2 FROM TAB2 WHERE col1 = col2)
                
   Bu iþlemin hýzlý olmasý için, subcol'un indexlenmiþ bir kolon olmasý
   gerekmektedir.
   
   7.4 sürümü ve sonrasýnda, IN aslýnda normal sorgularla ayný karmaþýk
   join tekniklerini kullanýr ve EXISTS'e tercih edilir.
   
    4.23) Outer join iþlemini nasýl yapabilirim?
    
   PostgreSQL outer joins islemlerini SQL standartlarýný kullanarak
   gerçekleþtirmektedir. Aþaðýda 2 örnek bulunmaktadýr:
SELECT *
FROM t1 LEFT OUTER JOIN t2 ON (t1.col = t2.col);
                
   ya da
SELECT *
FROM t1 LEFT OUTER JOIN t2 ON (t1.col = t2.col);
                
   Bu özdeþ sorgular t1.col' i t2.col'ye join ederler ve ayný zamanda
   t1'deki unjoined satýrlarý (t2'de eþlenmemiþ olanlarla) döndürürler.
   RIGHT JOIN t2'nin unjoined satýrlarýný ekleyecektir. Bir FULL join,
   eþleþmiþ bütün satýrlarý ve t1 ile t2'den tüm baðlanmamýþ (unjoined)
   satýrlarý alýr. OUTER sözcüðü seçimseldir ve LEFT, RIGHT ve FULL join
   iþlemlerinde olduðu kabul edilir. Sýradan join iþlemleri INNER JOIN
   olarak adlandýrýlýr.
   
   Önceki sürümlerde, OUTER JOINler UNION ve NOT IN kullanýlarak simüle
   edilebiliyordu. Örneðin, tab1 ve tab2'yi birleþtirirken, aþaðýdaki
   sorgu iki tablonun dýþtan baðlanmasýný saðlar:
SELECT tab1.col1, tab2.col2
FROM tab1, tab2
WHERE tab1.col1 = tab2.col1
UNION ALL
SELECT tab1.col1, NULL
FROM tab1
WHERE tab1.col1 NOT IN (SELECT tab2.col1 FROM tab2)
ORDER BY col1
                
    4.24) Ayný andan birden fazla veritabanýnda nasýl iþlem yapabilirim?
    
   Mevcut veritabanýnýz dýþýndaki baþka bir veritabanýnýzý sorgulamanýzýn
   bir yolu bulunmamaktadýr. Bunun nedeni, PostgreSQL'in veritabanýna
   özel sistem kataloglarý yüklemesidir. Bu nedenle, cross-database bir
   sorgunun nasýl davranacaðýný kestirmek zordur.
   
   contrib/dblink fonksiyon çaðrýlarýný kullanarak cross-database
   sorgulara izin verir. Tabii ki, bir istemci deðiþik veritabanlarýna
   ayný anda eriþim saðlayabilir ve bilgiyi bu þekilde birleþtirebilir.
   
    4.25) Bir fonksiyondan nasýl çoklu satýr ya da kolon döndürebilirim?
    
   7.3 sürümünde, bir fonksiyondan kolaylýkla çoklu satýr ya da sütun
   döndürebilirsiniz.
   (http://techdocs.postgresql.org/guides/SetReturningFunctions)
   
    4.26) Neden Pl/PgSQL fonksiyonlarý içinden güvenli bir þekilde tablo
    yaratma/kaldýrma iþlemlerini yapamýyoruz?
    
   PL/PgSQL fonksiyon içerikleri cache'ler. Bunun istenmeyen bir tarafý,
   eðer bir PL/PgSQL fonksiyonu geçici bir tabloya eriþiyorsa ve bu tablo
   ileride kaldýrýlýp yeniden oluþturulduktan sonra fonksiyon yeniden
   çaðrýlýrsa, fonksiyon çalýþmayacaktýr; çünkü cache'lenmiþ fonksiyon
   hala eski geçici tabloyu gösteriyor olacaktýr. Çözüm, geçici tablo
   eriþimleri için PL/PgSQL'de EXECUTE kullanmaktýr. Bu, sorgunun her
   seferinde yeniden iþlenmesini saðlayacaktýr.
   
    4.27) 4.28) Hangi þifreleme seçenekleri bulunmaktadýr?
    
     * contrib/pgcrypto SQL sorgularýnda kullanýlabilmesi için þifreleme
       fonksiyonlarý içermektedir.
     * Ýstemciden sunucuya iletiþimi þifrelemek için, sunucuda ssl
       seçeneði postgresql.conf içinde açýk olmalýdýr. Ayrýca,pg_hba.conf
       dosyasý içinde host ya da hostssl kaydý mutlaka olmalýdýr ve
       istemci sslmode kapatýlmamalýdýr. (Ayný zamanda,PostgreSQL'in
       doðal SSL baðlantýlarý dýþýnda ssh ya da ssl gibi 3.parti
       þifrelenmiþ veri iletimi de mümkündür.)
     * Veritabaný kullanýcý adý ve þifreleri 7.3 sürümü ile birlikte
       otomatik olarak þifrelenirler. Önceki sürümlerde, postgresql.conf
       içindeki PASSWORD_ENCRYPTION seçeneðini aktif hale getirmeniz
       gerekmektedir.
     * Sunucunun kendisini þifreli dosya sistemi üzerinde
       çalýþtýrabilirsiniz.
     _________________________________________________________________
   
                    PostgreSQL Özelliklerini Geniþletmek
                                      
    5.1) Kullanýcý-tanýmlý bir fonksiyon yazdým. psql'de çalýþtýrdýðým zaman
    neden core dump ediyor?
    
   Sorunun nedeni birden fazla þey olabilir. Kullanýcý-tanýmlý
   fonksiyonunuzu stand-alone bir programda çalýþtýrmayý deneyiniz.
   
    5.2) PostgreSQL'e nasýl yeni tipler/fonksiyonlar ekleyebilirim?
    
   Çalýþmalarýnýzý pgsql-hackers e-posta listesine gönderiniz. Kodunuz
   incelendikten sonra contrib dizinine konacaktýr.
   
    5.3) Bir tuple dondürmek icin bir C fonksiyonunu nasil yazarým?
    
   PostgreSQL 7.3 sürümü ile birlikte, C, PL/PgSQL ve SQL kullanýlarak
   tablo-döndüren fonksiyonlar tamamen desteklenmektedir. Ayrýntýlý bilgi
   için PostgreSQL 7.3.2 Kullanýcý Rehberi'ne bakabilrisiniz. Bir örneði
   contrib/tablefunc içinde bulabilirsiniz.
   
    5.4) Bir kaynak dosyasýnda deðiþiklik yaptým. Yeniden derlememe raðmen
    deðiþiklik geçerli olmuyor. Neden?
    
   Makefile'lar include dosyalarý için tam bir baðýmlýlýk içermezler.
   Öncelikle make clean, ardýndan da baska bir make iþlemi yapmanýz
   gerekir. GCC kullanýyorsanýz, configure betiðinin --enable-depend
   seçeneðini, derleyicinin baðýmlýlýklarý otomatik olarak hesaplamasý
   için kullanabilirsiniz.
